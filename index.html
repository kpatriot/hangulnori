<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÌïúÍ∏Ä¬∑Ïà´Ïûê Ïä§Ìã∞Ïª§ ÎÜÄÏù¥ (Ïà´ÏûêÌï©ÏπòÍ∏∞ Í∏∞Îä•ÌÉëÏû¨)</title>
    <style>
        :root {
            --bg-color: #f5f7ff;
            --primary-color: #722ed1;
            --secondary-color: #13c2c2;
            --accent-color: #eb2f96;
            --border-color: #c9d6ff;
        }

        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            font-family: "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
            background: var(--bg-color); 
            overflow: hidden; 
            position: fixed; 
            top: 0; left: 0; right: 0; bottom: 0;
            touch-action: none; 
            overscroll-behavior: none; 
            -webkit-user-select: none;
            user-select: none;
        }

        .top {
            background: #fff; padding: 10px;
            border-bottom: 3px solid var(--border-color);
            display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            z-index: 10;
            height: 35vh; 
            overflow-y: auto; 
            touch-action: pan-y; 
            -webkit-overflow-scrolling: touch; 
        }

        .row {
            display: flex; flex-wrap: wrap; justify-content: center;
            margin-bottom: 8px; gap: 6px;
            width: 100%; 
        }

        .letter {
            font-size: calc(1.8vh + 1.2vw); user-select: none; cursor: pointer;
            padding: 4px 8px; border-radius: 8px; background: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.1s;
            border: 1px solid #eee;
            touch-action: none; 
        }

        .letter:active { transform: scale(0.9); background: #f0f0f0; }
        .number { color: #1890ff; font-weight: bold; }
        .operator { color: #52c41a; font-weight: bold; }

        .board {
            position: relative; width: 100%; height: 65vh;
            background: #fff; overflow: hidden;
            touch-action: none; 
        }

        .btn-group {
            position: absolute; top: 15px; left: 15px; right: 15px;
            display: flex; gap: 8px; z-index: 1000; flex-wrap: wrap;
        }

        .btn {
            flex: 1; height: 45px; border: none; border-radius: 12px;
            color: #fff; font-weight: bold; font-size: 0.9rem;
            cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            white-space: nowrap; min-width: 60px;
        }

        .calc-btn { background: var(--primary-color); }
        .read-btn { background: var(--secondary-color); }
        .debug-btn { background: #faad14; }
        .result-btn { background: var(--accent-color); }
        .reset-btn { background: #f5222d; max-width: 60px; }

        .sticker {
            position: absolute; width: 80px; height: 80px;
            display: flex; align-items: center; justify-content: center;
            font-size: calc(4vh + 2vw); user-select: none;
            cursor: grab; transition: transform 0.05s;
            z-index: 100;
            touch-action: none; 
            border: 3px solid transparent; 
            border-radius: 12px;
            text-shadow: 1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff; 
        }

        .sticker:active { cursor: grabbing; transform: scale(1.1); }
        .result { color: var(--accent-color); font-weight: bold; pointer-events: auto; }

        .role-cho { border-color: #ff4d4f !important; background: rgba(255, 77, 79, 0.1); }
        .role-jung { border-color: #1890ff !important; background: rgba(24, 144, 255, 0.1); }
        .role-jong { border-color: #52c41a !important; background: rgba(82, 196, 26, 0.1); }

        .trash-can {
            position: absolute; bottom: 20px; right: 20px;
            width: 70px; height: 70px;
            background: #fff; border: 3px solid #ff4d4f; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 35px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            z-index: 500; transition: transform 0.2s;
            pointer-events: none;
        }
        .trash-can.hover { transform: scale(1.2); background: #fff1f0; }

        .group-box {
            position: absolute; border: 3px solid rgba(114, 46, 209, 0.5);
            border-radius: 16px; background: rgba(114, 46, 209, 0.05);
            pointer-events: none; z-index: 50;
        }
        
        .debug-box {
             position: absolute; border: 1px dashed #999; pointer-events: none; z-index: 40;
        }
    </style>
</head>
<body>

<div class="top" id="topFrame">
    <div class="row" id="consonants"></div>
    <div class="row" id="vowels"></div>
    <div class="row" id="numbers"></div>
</div>

<div class="board" id="board">
    <div class="btn-group">
        <button class="btn calc-btn" id="calcBtn">Í≥ÑÏÇ∞</button>
        <button class="btn read-btn" id="readBtn">ÏùΩÍ∏∞</button>
        <button class="btn debug-btn" id="debugBtn">ÏòÅÏó≠</button>
        <button class="btn result-btn" id="debugResultBtn">ÎØ∏Î¶¨Î≥¥Í∏∞</button>
        <button class="btn reset-btn" id="resetBtn">ÏÇ≠Ï†ú</button>
    </div>
    <div id="trashCan" class="trash-can">üóëÔ∏è</div>
</div>

<script>
    const board = document.getElementById("board");
    const trashCan = document.getElementById("trashCan");
    let debugOn = false;
    let detailedDebugOn = false; 
    let topZIndex = 100;

    const consonants = "„Ñ± „Ñ¥ „Ñ∑ „Ñπ „ÖÅ „ÖÇ „ÖÖ „Öá „Öà „Öä „Öã „Öå „Öç „Öé „Ñ≤ „Ñ∏ „ÖÉ „ÖÜ „Öâ".split(" ");
    const vowels = "„Öè „Öë „Öì „Öï „Öó „Öõ „Öú „Ö† „Ö° „Ö£ „Öê „Öî „Öí „Öñ".split(" ");
    const numbers = "0 1 2 3 4 5 6 7 8 9".split(" ");
    const operators = ["+", "-", "="];

    const jamoNames = {
        "„Ñ±":"Í∏∞Ïó≠", "„Ñ¥":"ÎãàÏùÄ", "„Ñ∑":"ÎîîÍ∑ø", "„Ñπ":"Î¶¨ÏùÑ", "„ÖÅ":"ÎØ∏Ïùå", "„ÖÇ":"ÎπÑÏùç", "„ÖÖ":"ÏãúÏò∑", "„Öá":"Ïù¥Ïùë", "„Öà":"ÏßÄÏùí", "„Öä":"ÏπòÏùì", "„Öã":"ÌÇ§Ïùî", "„Öå":"ÌÇ§Ïùï", "„Öç":"ÌîºÏùñ", "„Öé":"ÌûàÏùó",
        "„Ñ≤":"ÏåçÍ∏∞Ïó≠", "„Ñ∏":"ÏåçÎîîÍ∑ø", "„ÖÉ":"ÏåçÎπÑÏùç", "„ÖÜ":"ÏåçÏãúÏò∑", "„Öâ":"ÏåçÏßÄÏùí",
        "„Öè":"ÏïÑ", "„Öë":"Ïïº", "„Öì":"Ïñ¥", "„Öï":"Ïó¨", "„Öó":"Ïò§", "„Öõ":"Ïöî", "„Öú":"Ïö∞", "„Ö†":"Ïú†", "„Ö°":"Ïúº", "„Ö£":"Ïù¥", "„Öê":"Ïï†", "„Öî":"Ïóê", "„Öí":"Ïñò", "„Öñ":"Ïòà",
        "„Öò":"ÏôÄ", "„Öô":"Ïôú", "„Öö":"Ïô∏", "„Öù":"Ïõå", "„Öû":"Ïõ®", "„Öü":"ÏúÑ", "„Ö¢":"Ïùò",
        "+":"ÎçîÌïòÍ∏∞", "-":"ÎπºÍ∏∞", "=":"Îäî"
    };

    const DOUBLE_VOWELS = { "„Öó„Öè":"„Öò", "„Öó„Öê":"„Öô", "„Öó„Ö£":"„Öö", "„Öú„Öì":"„Öù", "„Öú„Öî":"„Öû", "„Öú„Ö£":"„Öü", "„Ö°„Ö£":"„Ö¢" };
    const DOUBLE_JONG = { "„Ñ±„ÖÖ":"„Ñ≥", "„Ñ¥„Öà":"„Ñµ", "„Ñ¥„Öé":"„Ñ∂", "„Ñπ„Ñ±":"„Ñ∫", "„Ñπ„ÖÅ":"„Ñª", "„Ñπ„ÖÇ":"„Ñº", "„Ñπ„ÖÖ":"„ÑΩ", "„Ñπ„Öå":"„Ñæ", "„Ñπ„Öç":"„Ñø", "„Ñπ„Öé":"„ÖÄ", "„ÖÇ„ÖÖ":"„ÖÑ" };

    const CHO_TABLE = "„Ñ±„Ñ≤„Ñ¥„Ñ∑„Ñ∏„Ñπ„ÖÅ„ÖÇ„ÖÉ„ÖÖ„ÖÜ„Öá„Öà„Öâ„Öä„Öã„Öå„Öç„Öé";
    const JUNG_TABLE = "„Öè„Öê„Öë„Öí„Öì„Öî„Öï„Öñ„Öó„Öò„Öô„Öö„Öõ„Öú„Öù„Öû„Öü„Ö†„Ö°„Ö¢„Ö£";
    const JONG_TABLE = ["","„Ñ±","„Ñ≤","„Ñ≥","„Ñ¥","„Ñµ","„Ñ∂","„Ñ∑","„Ñπ","„Ñ∫","„Ñª","„Ñº","„ÑΩ","„Ñæ","„Ñø","„ÖÄ","„ÖÅ","„ÖÇ","„ÖÑ","„ÖÖ","„ÖÜ","„Öá","„Öà","„Öä","„Öã","„Öå","„Öç","„Öé"];

    function makePalette(chars, container, cls) {
        chars.forEach(c => {
            const el = document.createElement("div");
            el.className = "letter " + (cls || "");
            el.textContent = c;
            container.appendChild(el);
            el.addEventListener("pointerdown", e => startDrag(e, c));
        });
    }

    makePalette(consonants, document.getElementById("consonants"));
    makePalette(vowels, document.getElementById("vowels"));
    makePalette(numbers, document.getElementById("numbers"), "number");
    makePalette(operators, document.getElementById("numbers"), "operator");

    document.addEventListener('touchmove', function(e) {
        if (e.target.closest('.sticker') || e.target.closest('.board')) {
            e.preventDefault();
            return;
        }
        const topArea = e.target.closest('.top');
        if (topArea) {
            if (e.target.closest('.letter')) {
                e.preventDefault();
                return;
            }
            if (topArea.scrollHeight > topArea.clientHeight) {
                return; 
            }
        }
        if (e.cancelable) {
            e.preventDefault();
        }
    }, { passive: false });

    function speakText(text) {
        speechSynthesis.cancel();
        const msg = new SpeechSynthesisUtterance(text);
        msg.lang = 'ko-KR';
        speechSynthesis.speak(msg);
    }

    function isOverTrash(x, y) {
        const tr = trashCan.getBoundingClientRect();
        return (x > tr.left && x < tr.right && y > tr.top && y < tr.bottom);
    }

    function handleDoubleTouch(s) {
        let lastTap = 0;
        s.addEventListener('touchstart', (e) => {
            const now = Date.now();
            if (now - lastTap < 300) {
                e.preventDefault(); 
                s.remove();
                speakText("ÏÇ≠Ï†ú");
                updateGroups();
            }
            lastTap = now;
        }, { passive: false });
    }

    function startDrag(e, char) {
        e.preventDefault(); 
        speakText(jamoNames[char] || char);
        const s = document.createElement("div");
        s.className = "sticker"; s.textContent = char;
        s.style.zIndex = ++topZIndex;
        document.body.appendChild(s);

        const move = (ev) => {
            ev.preventDefault();
            const clientX = ev.clientX || (ev.touches && ev.touches[0].clientX);
            const clientY = ev.clientY || (ev.touches && ev.touches[0].clientY);
            
            s.style.left = clientX - 40 + "px";
            s.style.top = clientY - 40 + "px";
            
            if(isOverTrash(clientX, clientY)) trashCan.classList.add('hover');
            else trashCan.classList.remove('hover');
        };

        const up = (ev) => {
            document.removeEventListener("pointermove", move);
            document.removeEventListener("pointerup", up);
            trashCan.classList.remove('hover');
            
            const clientX = ev.clientX || (ev.changedTouches && ev.changedTouches[0].clientX);
            const clientY = ev.clientY || (ev.changedTouches && ev.changedTouches[0].clientY);

            const b = board.getBoundingClientRect();
            if (clientY < b.top || clientX < b.left || clientX > b.right || clientY > b.bottom || isOverTrash(clientX, clientY)) {
                s.remove(); 
                if(isOverTrash(clientX, clientY)) speakText("Î≤ÑÎ†∏Ïñ¥Ïöî");
                updateGroups(); return;
            }
            
            board.appendChild(s);
            s.style.left = clientX - b.left - 40 + "px";
            s.style.top = clientY - b.top - 40 + "px";
            enableMove(s); 
            handleDoubleTouch(s);
            updateGroups();
        };
        document.addEventListener("pointermove", move, { passive: false });
        document.addEventListener("pointerup", up);
    }

    function enableMove(s) {
        s.onpointerdown = (e) => {
            e.preventDefault(); e.stopPropagation();
            s.style.zIndex = ++topZIndex;
            speakText(jamoNames[s.textContent] || s.textContent);
            
            const r = s.getBoundingClientRect();
            const b = board.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            const dx = clientX - r.left;
            const dy = clientY - r.top;
            
            const move = (ev) => {
                ev.preventDefault(); 
                const cx = ev.clientX || (ev.touches && ev.touches[0].clientX);
                const cy = ev.clientY || (ev.touches && ev.touches[0].clientY);

                s.style.left = cx - b.left - dx + "px";
                s.style.top = cy - b.top - dy + "px";
                if(isOverTrash(cx, cy)) trashCan.classList.add('hover');
                else trashCan.classList.remove('hover');
            };
            
            const up = (ev) => {
                document.removeEventListener('pointermove', move);
                document.removeEventListener('pointerup', up);
                trashCan.classList.remove('hover');
                
                const cx = ev.clientX || (ev.changedTouches && ev.changedTouches[0].clientX);
                const cy = ev.clientY || (ev.changedTouches && ev.changedTouches[0].clientY);

                if (cy < b.top || cx < b.left || cx > b.right || cy > b.bottom || isOverTrash(cx, cy)) {
                    s.remove();
                    if(isOverTrash(cx, cy)) speakText("Î≤ÑÎ†∏Ïñ¥Ïöî");
                }
                updateGroups();
            };
            document.addEventListener('pointermove', move, { passive: false });
            document.addEventListener('pointerup', up);
        };
    }

    function near(a, b) {
        const r1 = a.getBoundingClientRect();
        const r2 = b.getBoundingClientRect();
        const cx1 = r1.left + r1.width / 2;
        const cy1 = r1.top + r1.height / 2;
        const cx2 = r2.left + r2.width / 2;
        const cy2 = r2.top + r2.height / 2;
        
        // Ïà´Ïûê Í∑∏Î£πÌïëÏùÑ ÏúÑÌï¥ Í∞ÄÎ°ú Í±∞Î¶¨ Ïó¨Ïú† (Ï∂©Î∂ÑÌûà ÎÑìÍ≤å)
        return Math.abs(cx1 - cx2) < 140 && Math.abs(cy1 - cy2) < 110;
    }

    function getGroups() {
        const stickers = [...document.querySelectorAll('.sticker')];
        const visited = new Set();
        const groups = [];
        stickers.forEach(s => {
            if (visited.has(s)) return;
            const g = [], stack = [s];
            visited.add(s);
            while (stack.length) {
                const cur = stack.pop();
                g.push(cur);
                stickers.forEach(o => {
                    if (!visited.has(o) && near(cur, o)) {
                        visited.add(o); stack.push(o);
                    }
                });
            }
            groups.push(g);
        });
        return groups;
    }

    function analyzeMultiCharHangul(group) {
        group.forEach(s => s.classList.remove('role-cho', 'role-jung', 'role-jong'));

        const sortedStickers = [...group].sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);
        const rawVowels = sortedStickers.filter(s => vowels.includes(s.textContent) || "„Öò„Öô„Öö„Öù„Öû„Öü„Ö¢".includes(s.textContent));
        const rawConsonants = sortedStickers.filter(s => consonants.includes(s.textContent));

        if (rawVowels.length === 0) return null;

        let nuclei = [];
        let usedVowels = new Set();

        for (let i = 0; i < rawVowels.length; i++) {
            if (usedVowels.has(rawVowels[i])) continue;
            
            let v1 = rawVowels[i];
            let nucleus = {
                vowels: [v1],
                text: v1.textContent,
                centerX: 0, centerY: 0,
                cho: [], jong: [] 
            };
            usedVowels.add(v1);

            if (i + 1 < rawVowels.length) {
                let v2 = rawVowels[i+1];
                let r1 = v1.getBoundingClientRect();
                let r2 = v2.getBoundingClientRect();
                
                if (Math.abs(r1.right - r2.left) < 60 && !usedVowels.has(v2)) {
                    let key = v1.textContent + v2.textContent;
                    if (DOUBLE_VOWELS[key]) {
                        nucleus.vowels.push(v2);
                        nucleus.text = DOUBLE_VOWELS[key];
                        usedVowels.add(v2);
                        i++;
                    }
                }
            }
            nuclei.push(nucleus);
        }

        nuclei.forEach(n => {
            let minX = Math.min(...n.vowels.map(v => v.getBoundingClientRect().left));
            let maxX = Math.max(...n.vowels.map(v => v.getBoundingClientRect().right));
            let minY = Math.min(...n.vowels.map(v => v.getBoundingClientRect().top));
            let maxY = Math.max(...n.vowels.map(v => v.getBoundingClientRect().bottom));
            n.centerX = (minX + maxX) / 2;
            n.centerY = (minY + maxY) / 2;
            
            if (detailedDebugOn) {
                n.vowels.forEach(v => v.classList.add('role-jung'));
            }
        });

        rawConsonants.forEach(c => {
            let r = c.getBoundingClientRect();
            let cx = r.left + r.width/2;
            let cy = r.top + r.height/2;
            
            let closestNucleus = null;
            let minDist = Infinity;

            nuclei.forEach(n => {
                let dx = cx - n.centerX;
                let dy = cy - n.centerY;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < minDist) {
                    minDist = dist;
                    closestNucleus = n;
                }
            });

            if (closestNucleus) {
                let dy = cy - closestNucleus.centerY;
                if (dy > 30) {
                    closestNucleus.jong.push(c);
                } else {
                    closestNucleus.cho.push(c);
                }
            }
        });

        let resultString = "";
        
        nuclei.forEach(n => {
            let choChar = "„Öá";
            if (n.cho.length > 0) {
                n.cho.sort((a,b) => b.getBoundingClientRect().left - a.getBoundingClientRect().left);
                choChar = n.cho[0].textContent;
                if (detailedDebugOn) n.cho[0].classList.add('role-cho');
            }

            let jongChar = "";
            if (n.jong.length > 0) {
                n.jong.sort((a,b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);
                
                if (n.jong.length >= 2) {
                    let key = n.jong[0].textContent + n.jong[1].textContent;
                    if (DOUBLE_JONG[key]) {
                        jongChar = DOUBLE_JONG[key];
                        if (detailedDebugOn) {
                            n.jong[0].classList.add('role-jong');
                            n.jong[1].classList.add('role-jong');
                        }
                    } else {
                        jongChar = n.jong[n.jong.length-1].textContent;
                        if (detailedDebugOn) n.jong[n.jong.length-1].classList.add('role-jong');
                    }
                } else {
                    jongChar = n.jong[0].textContent;
                    if (detailedDebugOn) n.jong[0].classList.add('role-jong');
                }
            }

            const choIdx = CHO_TABLE.indexOf(choChar);
            const jungIdx = JUNG_TABLE.indexOf(n.text);
            const jongIdx = jongChar ? JONG_TABLE.indexOf(jongChar) : 0;

            if (choIdx !== -1 && jungIdx !== -1) {
                resultString += String.fromCharCode(0xAC00 + (choIdx * 21 * 28) + (jungIdx * 28) + jongIdx);
            } else {
                resultString += n.text;
            }
        });

        return resultString;
    }

    function calculateExpression(str) {
        const tokens = str.replace('=', '').match(/(\d+|[+-])/g);
        if (!tokens) return null;
        let result = parseInt(tokens[0]);
        for (let i = 1; i < tokens.length; i += 2) {
            const operator = tokens[i];
            const nextVal = parseInt(tokens[i + 1]);
            if (isNaN(nextVal)) break;
            if (operator === '+') result += nextVal;
            if (operator === '-') result -= nextVal;
        }
        return result;
    }

    function convertNumberToKorean(numStr) {
        if (numStr === '0') return 'ÏòÅ';
        const units = ['', 'Ïã≠', 'Î∞±', 'Ï≤ú', 'Îßå'];
        const digits = ['', 'Ïùº', 'Ïù¥', 'ÏÇº', 'ÏÇ¨', 'Ïò§', 'Ïú°', 'Ïπ†', 'Ìåî', 'Íµ¨'];
        let result = '';
        let num = parseInt(numStr);
        let str = String(num);
        let len = str.length;
        if (len > 5) return numStr; 

        for (let i = 0; i < len; i++) {
            let n = parseInt(str[i]);
            let unit = units[len - 1 - i];
            if (n > 0) {
                if (n === 1 && (len - 1 - i) > 0) {
                    result += unit;
                } else {
                    result += digits[n] + unit;
                }
            }
        }
        return result;
    }

    // [Ïã†Í∑ú Í∏∞Îä•] Í∑∏Î£π ÎÇ¥ Ïà´Ïûê Ïä§Ìã∞Ïª§Îì§ÏùÑ Î≥ëÌï©ÌïòÏó¨ Î∂ÑÏÑù
    function analyzeNumberGroup(group) {
        const sorted = [...group].sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);
        let tokens = [];
        let currentNumber = "";
        
        sorted.forEach(s => {
            const txt = s.textContent;
            if (/\d/.test(txt)) {
                // Ïà´ÏûêÏù∏ Í≤ΩÏö∞ Í≥ÑÏÜç ÎàÑÏ†Å
                currentNumber += txt;
            } else {
                // Ïà´ÏûêÍ∞Ä ÎÅäÍ∏∞Î©¥(Ïó∞ÏÇ∞Ïûê Îì±) ÏßÄÍ∏àÍπåÏßÄ ÎàÑÏ†ÅÎêú Ïà´ÏûêÎ•º ÌÜ†ÌÅ∞Ïóê Ï∂îÍ∞Ä
                if (currentNumber) {
                    tokens.push(currentNumber);
                    currentNumber = "";
                }
                tokens.push(txt);
            }
        });
        
        // ÎßàÏßÄÎßâÏóê ÎÇ®ÏùÄ Ïà´Ïûê Ï≤òÎ¶¨
        if (currentNumber) {
            tokens.push(currentNumber);
        }

        // ÌÜ†ÌÅ∞Îì§ÏùÑ Î≥ÄÌôòÌïòÏó¨ Î∞òÌôò
        return tokens.map(part => {
             if (jamoNames[part]) return jamoNames[part]; // Ïó∞ÏÇ∞Ïûê Î≥ÄÌôò
             if (/^\d+$/.test(part)) return convertNumberToKorean(part); // Ïà´Ïûê Î≠âÏπò Î≥ÄÌôò
             return part;
        }).join(' ');
    }

    function getReadingText(group) {
        const sorted = [...group].sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);
        const isHangulGroup = sorted.some(s => vowels.includes(s.textContent) || "„Öò„Öô„Öö„Öù„Öû„Öü„Ö¢".includes(s.textContent));
        
        if (isHangulGroup) {
            const res = analyzeMultiCharHangul(group);
            if (res) return res;
        } else {
            // ÌïúÍ∏ÄÏù¥ ÏïÑÎãàÎ©¥ ÏÉâÍπî Ï†úÍ±∞
            group.forEach(s => s.classList.remove('role-cho', 'role-jung', 'role-jong'));
            // [Î≥ÄÍ≤ΩÎê®] Ïà´Ïûê/Ïó∞ÏÇ∞Ïûê Í∑∏Î£πÏùÄ Î≥ÑÎèÑ Î≥ëÌï© Î°úÏßÅÏùÑ ÌÉúÏõÄ
            return analyzeNumberGroup(group);
        }

        // Fallback (ÌïúÍ∏Ä Î∂ÑÏÑù Ïã§Ìå® Ïãú)
        return analyzeNumberGroup(group);
    }

    function updateGroups() {
        document.querySelectorAll('.group-box').forEach(d => d.remove());
        
        getGroups().forEach(g => {
            const rects = g.map(s => s.getBoundingClientRect());
            const b = board.getBoundingClientRect();
            const minX = Math.min(...rects.map(r => r.left));
            const minY = Math.min(...rects.map(r => r.top));
            const maxX = Math.max(...rects.map(r => r.right));
            const maxY = Math.max(...rects.map(r => r.bottom));

            const box = document.createElement('div');
            box.className = 'group-box';
            box.style.left = (minX - b.left - 10) + 'px';
            box.style.top = (minY - b.top - 10) + 'px';
            box.style.width = (maxX - minX + 20) + 'px';
            box.style.height = (maxY - minY + 20) + 'px';
            
            const label = document.createElement('div');
            label.style = "position:absolute; top:-35px; background:#fff; padding:4px 8px; border-radius:8px; color:#722ed1; font-weight:bold; white-space:nowrap; border:2px solid #722ed1; box-shadow:0 2px 5px rgba(0,0,0,0.1);";
            
            label.textContent = getReadingText(g);
            
            box.appendChild(label);
            board.appendChild(box);
        });
    }

    calcBtn.onclick = () => {
        document.querySelectorAll('.result').forEach(r => r.remove());
        getGroups().forEach(g => {
            const gSorted = [...g].sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);
            const expressionText = gSorted.map(s => s.textContent).join('');
            if (expressionText.includes('=') && /[\d]/.test(expressionText)) {
                const result = calculateExpression(expressionText);
                if (result !== null) {
                    const eqSticker = gSorted.find(s => s.textContent === '=');
                    const r = document.createElement('div');
                    r.className = 'sticker result'; 
                    r.textContent = result;
                    r.style.left = eqSticker.offsetLeft + 90 + 'px'; 
                    r.style.top = eqSticker.offsetTop + 'px';
                    r.style.zIndex = ++topZIndex;
                    board.appendChild(r);
                    enableMove(r);
                    handleDoubleTouch(r);
                }
            }
        });
    };

    readBtn.onclick = () => {
        speechSynthesis.cancel();
        const groups = getGroups().sort((a, b) => {
            const aLeft = Math.min(...a.map(s => s.getBoundingClientRect().left));
            const bLeft = Math.min(...b.map(s => s.getBoundingClientRect().left));
            return aLeft - bLeft;
        });

        let i = 0;
        function speak() {
            if (i >= groups.length) return;
            const txt = getReadingText(groups[i]);
            const u = new SpeechSynthesisUtterance(txt);
            u.lang = 'ko-KR';
            u.onend = () => { i++; setTimeout(speak, 300); };
            speechSynthesis.speak(u);
        }
        speak();
    };

    debugBtn.onclick = () => { 
        debugOn = !debugOn; 
        debugBtn.textContent = debugOn ? "ÏòÅÏó≠ OFF" : "ÏòÅÏó≠";
        document.querySelectorAll('.debug-box').forEach(d => d.remove());
        if(debugOn) {
            document.querySelectorAll('.sticker').forEach(s => {
                const r = s.getBoundingClientRect(); const b = board.getBoundingClientRect();
                const d = document.createElement('div');
                d.className = 'debug-box';
                d.style.left = (r.left - b.left) + 'px';
                d.style.top = (r.top - b.top) + 'px';
                d.style.width = r.width + 'px';
                d.style.height = r.height + 'px';
                board.appendChild(d);
            });
        }
    };
    
    debugResultBtn.onclick = () => { 
        detailedDebugOn = !detailedDebugOn; 
        debugResultBtn.textContent = detailedDebugOn ? "ÎØ∏Î¶¨Î≥¥Í∏∞ ON" : "ÎØ∏Î¶¨Î≥¥Í∏∞";
        updateGroups(); 
    };

    resetBtn.onclick = () => {
        speechSynthesis.cancel();
        document.querySelectorAll('.sticker, .group-box, .debug-box').forEach(e => e.remove());
        topZIndex = 100;
    };
</script>
</body>
</html>